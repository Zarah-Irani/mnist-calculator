<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Handwritten Expression → Answer (ONNX)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <style>
    :root{--bg:#0f1220;--card:#171a2b;--accent:#7c9cf5;--muted:#9aa3b2;--text:#eef1f7;--ok:#6ee7b7;}
    *{box-sizing:border-box}
    body{margin:0;padding:24px;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;color:var(--text);background:#0f1220;}
    .wrap{max-width:1100px;margin:0 auto;display:grid;gap:18px}
    .row{display:flex;flex-wrap:wrap;gap:16px;align-items:stretch}
    .card{background:var(--card);border:1px solid rgba(124,156,245,.2);border-radius:16px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25)}
    h1{margin:0 0 6px}
    .muted{color:var(--muted)}
    canvas#pad{width:720px;height:180px;max-width:100%;background:#000;border-radius:18px;border:1px dashed rgba(255,255,255,.15);touch-action:none;cursor:crosshair}
    .controls{display:flex;gap:10px;flex-wrap:wrap;margin-top:12px;align-items:center}
    button,select,input[type="range"]{background:#101426;color:#eaf0ff;border:1px solid rgba(124,156,245,.35);padding:10px 12px;border-radius:12px;cursor:pointer;font-weight:600}
    button:hover{border-color:var(--accent)}
    .output{display:grid;gap:10px}
    .expr{font-size:22px;background:#0b0f23;border:1px solid rgba(124,156,245,.25);padding:12px;border-radius:12px;word-break:break-all;min-height:54px}
    .pill{padding:6px 10px;border:1px solid rgba(124,156,245,.3);border-radius:999px;background:#0f1430}
    .grid{display:grid;gap:10px}
    .mini{font-size:12px;color:var(--muted)}
    .dbg{display:flex;flex-wrap:wrap;gap:8px}
    .dbg .tile{display:flex;flex-direction:column;align-items:center;gap:4px}
    .dbg canvas{width:56px;height:56px;image-rendering:pixelated;background:#0b0d17;border-radius:8px;border:1px solid rgba(255,255,255,.1)}
  </style>
</head>
<body>
<div class="wrap">
  <div>
    <h1>Handwritten Expression → Answer</h1>
    <div class="muted">Write the whole expression (e.g., <b>3+4</b>, <b>(12-5)/7</b>, <b>√(9)+2</b>) on one canvas. Click Compute.</div>
  </div>

  <div class="row">
    <div class="card" style="flex:1 1 720px;min-width:320px">
      <h3>Draw expression</h3>
      <canvas id="pad" width="1200" height="300"></canvas>
      <div class="controls">
        <button id="compute">Compute</button>
        <button id="clear">Clear</button>
        <label>Brush <input id="brush" type="range" min="8" max="36" step="1" value="24" /></label>
        <label><input type="checkbox" id="showBoxes" checked /> Show char boxes</label>
        <label><input type="checkbox" id="invert" /> Invert colors</label>
        <span id="status" class="muted">loading model…</span>
      </div>
      <div class="mini">Tip: write white ink on black, thick & centered baseline. Supported: digits 0–9, +, −, /, √, ( ).</div>
    </div>

    <div class="card output" style="flex:1 1 360px;min-width:300px">
      <div class="grid">
        <div class="pill">Expression: <span id="expr">—</span></div>
        <div class="pill">Answer: <span id="ans">—</span></div>
      </div>
      <div>
        <h4>Detected characters</h4>
        <div id="chars" class="dbg"></div>
      </div>
    </div>
  </div>
</div>

<script>
/* ================= Canvas drawing ================= */
const pad = document.getElementById('pad');
const ctx = pad.getContext('2d');
function resetCanvas(){ ctx.fillStyle="#000"; ctx.fillRect(0,0,pad.width,pad.height); }
resetCanvas();
let drawing=false, last=null, brush=24;
function pos(e){ const r=pad.getBoundingClientRect(); const p=e.touches?e.touches[0]:e;
  return {x:(p.clientX-r.left)*(pad.width/r.width), y:(p.clientY-r.top)*(pad.height/r.height)} }
function stroke(a,b){ ctx.lineJoin="round"; ctx.lineCap="round"; ctx.strokeStyle="#fff"; ctx.lineWidth=brush;
  ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(b.x,b.y); ctx.stroke(); }
pad.addEventListener('mousedown',e=>{drawing=true; last=pos(e); stroke(last,last);});
window.addEventListener('mousemove',e=>{ if(!drawing) return; const p=pos(e); stroke(last,p); last=p; });
window.addEventListener('mouseup',()=>drawing=false);
pad.addEventListener('touchstart',e=>{drawing=true; last=pos(e); stroke(last,last); e.preventDefault()},{passive:false});
pad.addEventListener('touchmove',e=>{ if(!drawing) return; const p=pos(e); stroke(last,p); last=p; e.preventDefault()},{passive:false});
pad.addEventListener('touchend',()=>drawing=false);
document.getElementById('clear').onclick = ()=> resetCanvas();
document.getElementById('brush').oninput = e => brush=+e.target.value;

/* ================= Robust loader for GitHub Pages ================= */
const statusEl = document.getElementById('status');
function setStatus(msg) { statusEl.textContent = msg; console.log(msg); }

// Make ORT WASM reliable on Pages
ort.env.wasm.wasmPaths = "https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/";
ort.env.wasm.numThreads = 1;

async function headOk(url) {
  const r = await fetch(url, { method: "HEAD", cache: "no-store" });
  if (!r.ok) throw new Error(`HTTP ${r.status} ${r.statusText} for ${url}`);
  return url;
}

async function loadLabels() {
  setStatus("loading labels.json…");
  const r = await fetch("labels.json", { cache: "no-store" });
  if (!r.ok) throw new Error(`labels.json HTTP ${r.status}`);
  return await r.json();
}

async function loadSession() {
  const candidates = [
    "eqsym_tiny_fp16.onnx",
    "eqsym_tiny_int8.onnx",
    "eqsym_tiny_fp32.onnx",
  ];

  // verify existence (good diagnostics if path wrong)
  let chosen = null, lastErr = null;
  for (const p of candidates) {
    try { await headOk(p); chosen = p; break; }
    catch (e) { console.warn("HEAD fail:", p, e); lastErr = e; }
  }
  if (!chosen) {
    setStatus("❌ Could not find any ONNX file (check file names/paths).");
    throw lastErr || new Error("No .onnx found");
  }

  // Try WASM first for reliability; fall back to WebGPU
  try {
    setStatus(`loading (wasm) ${chosen}…`);
    const s = await ort.InferenceSession.create(chosen, {
      executionProviders: ["wasm"],
      graphOptimizationLevel: "all",
    });
    setStatus(`model ready ✅ (WASM, ${chosen})`);
    return s;
  } catch (e1) {
    console.warn("WASM failed, trying WebGPU:", e1);
    setStatus(`loading (webgpu) ${chosen}…`);
    const s2 = await ort.InferenceSession.create(chosen, {
      executionProviders: ["webgpu","wasm"],
      graphOptimizationLevel: "all",
    });
    setStatus(`model ready ✅ (WebGPU, ${chosen})`);
    return s2;
  }
}

let session = null, labels = null;

(async () => {
  try {
    labels  = await loadLabels();
    session = await loadSession();
  } catch (e) {
    setStatus("❌ " + (e?.message || e));
    console.error(e);
  }
})();

/* ================= Segmentation helpers ================= */
function binarize(imgData, thresh=0.28, invert=false){
  const {width:W, height:H, data} = imgData;
  const bin = new Uint8Array(W*H);
  for(let i=0;i<W*H;i++){
    const r=data[i*4], g=data[i*4+1], b=data[i*4+2];
    let v=(r+g+b)/3/255;            // 0..1 (white=1)
    if(invert) v = 1 - v;
    bin[i] = v>thresh ? 1 : 0;
  }
  return {W,H,bin};
}
function components({W,H,bin}){
  const labels = new Int32Array(W*H).fill(-1);
  const boxes = [];
  let lab=0;
  const qx=new Int32Array(W*H), qy=new Int32Array(W*H);
  for(let y=0;y<H;y++) for(let x=0;x<W;x++){
    const idx=y*W+x;
    if(!bin[idx] || labels[idx]!==-1) continue;
    let head=0,tail=0; qx[tail]=x; qy[tail]=y; tail++; labels[idx]=lab;
    let minx=x,maxx=x,miny=y,maxy=y, area=0;
    while(head<tail){
      const cx=qx[head], cy=qy[head]; head++; area++;
      for(let dy=-1;dy<=1;dy++)for(let dx=-1;dx<=1;dx++){
        if(dx===0&&dy===0) continue;
        const nx=cx+dx, ny=cy+dy;
        if(nx<0||ny<0||nx>=W||ny>=H) continue;
        const nidx=ny*W+nx;
        if(bin[nidx] && labels[nidx]===-1){
          labels[nidx]=lab; qx[tail]=nx; qy[tail]=ny; tail++;
          if(nx<minx)minx=nx; if(nx>maxx)maxx=nx; if(ny<miny)miny=ny; if(ny>maxy)maxy=ny;
        }
      }
    }
    if(area>=30) boxes.push({x:minx,y:miny,w:maxx-minx+1,h:maxy-miny+1,area});
    lab++;
  }
  boxes.sort((a,b)=>a.x-b.x);
  // merge nearby boxes horizontally (bridges broken strokes)
  const merged=[];
  for(const b of boxes){
    if(!merged.length){ merged.push(b); continue; }
    const prev=merged[merged.length-1];
    const gap = b.x - (prev.x+prev.w);
    const overlapY = !(b.y > prev.y+prev.h || prev.y > b.y+b.h);
    if(gap<=10 && overlapY){
      const nx=Math.min(prev.x,b.x), ny=Math.min(prev.y,b.y);
      const rx=Math.max(prev.x+prev.w, b.x+b.w), ry=Math.max(prev.y+prev.h, b.y+b.h);
      prev.x=nx; prev.y=ny; prev.w=rx-nx; prev.h=ry-ny;
    }else merged.push(b);
  }
  return merged;
}
function centerOfMassShift(canvas){
  const g = canvas.getContext('2d');
  const d = g.getImageData(0,0,28,28);
  let sum=0,sx=0,sy=0;
  for(let y=0;y<28;y++)for(let x=0;x<28;x++){
    const i=(y*28+x)*4;
    const v=(d.data[i]+d.data[i+1]+d.data[i+2])/3; // 0..255
    sum+=v; sx+=x*v; sy+=y*v;
  }
  if(sum<1) return;
  const cx=sx/sum, cy=sy/sum;
  const dx=Math.round(14-cx), dy=Math.round(14-cy);
  if(dx===0 && dy===0) return;
  const tmp=document.createElement('canvas'); tmp.width=28; tmp.height=28;
  tmp.getContext('2d').drawImage(canvas,dx,dy);
  g.clearRect(0,0,28,28); g.drawImage(tmp,0,0);
}
function cropTo28(imgData, box, pad=8){
  const {width:W, height:H, data} = imgData;
  const sx = Math.max(0, box.x - pad), sy = Math.max(0, box.y - pad);
  const ex = Math.min(W, box.x + box.w + pad), ey = Math.min(H, box.y + box.h + pad);
  const cw = ex - sx, ch = ey - sy;

  const tmp=document.createElement('canvas'); tmp.width=cw; tmp.height=ch;
  const tctx=tmp.getContext('2d', {willReadFrequently:true});
  const src = new ImageData(new Uint8ClampedArray(cw*ch*4), cw, ch);
  for(let y=0;y<ch;y++) for(let x=0;x<cw;x++){
    const di=((sy+y)*W + (sx+x))*4, oi=(y*cw+x)*4;
    src.data[oi]=data[di]; src.data[oi+1]=data[di+1]; src.data[oi+2]=data[di+2]; src.data[oi+3]=255;
  }
  tctx.putImageData(src,0,0);

  const dst=document.createElement('canvas'); dst.width=28; dst.height=28;
  const dctx=dst.getContext('2d');
  dctx.fillStyle="#000"; dctx.fillRect(0,0,28,28);
  dctx.imageSmoothingEnabled = false; // crisp downscale

  const scale = Math.min(28/cw, 28/ch);
  const rw = Math.max(1, Math.floor(cw*scale)), rh = Math.max(1, Math.floor(ch*scale));
  const dx = Math.floor((28-rw)/2), dy = Math.floor((28-rh)/2);
  dctx.drawImage(tmp, 0,0,cw,ch, dx,dy,rw,rh);

  centerOfMassShift(dst);  // MNIST-like centering
  return dst;
}
function tensorFrom28(canvas28){
  const mean=0.1307, std=0.3081;
  const inv = document.getElementById('invert').checked;
  const g = canvas28.getContext('2d').getImageData(0,0,28,28).data;
  const arr = new Float32Array(1*1*28*28);
  for(let i=0;i<28*28;i++){
    const r=g[i*4], y=g[i*4+1], b=g[i*4+2];
    let v=(r+y+b)/3/255; if(inv) v=1-v;
    arr[i]=(v-mean)/std;
  }
  return new ort.Tensor('float32', arr, [1,1,28,28]);
}
function softmax(a){ const m=Math.max(...a); const e=a.map(v=>Math.exp(v-m)); const s=e.reduce((x,y)=>x+y,0); return e.map(v=>v/s); }

/* ================= Compute whole-canvas ================= */
const exprEl = document.getElementById('expr');
const ansEl  = document.getElementById('ans');
const charsEl= document.getElementById('chars');
const showBoxes = document.getElementById('showBoxes');

document.getElementById('compute').onclick = async ()=>{
  if(!session){ alert('Model not ready'); return; }
  const img = ctx.getImageData(0,0,pad.width,pad.height);
  const bin = binarize(img, 0.28, document.getElementById('invert').checked);
  const boxes = components(bin);

  // draw boxes overlay
  if(showBoxes.checked){
    ctx.putImageData(img,0,0);
    ctx.save(); ctx.strokeStyle="#44f1a8aa"; ctx.lineWidth=3;
    for(const b of boxes){ ctx.strokeRect(b.x,b.y,b.w,b.h); }
    ctx.restore();
  }

  charsEl.innerHTML=''; let tokens=[];
  for(const b of boxes){
    const c28 = cropTo28(img, b, 8);
    const tensor = tensorFrom28(c28);
    const out = await session.run({[session.inputNames[0]]:tensor});
    const logits = Array.from(out[session.outputNames[0]].data);
    const probs = softmax(logits);
    const best = probs.indexOf(Math.max(...probs));
    const label = (labels && labels[String(best)]) ? labels[String(best)] : '?';

    if(tokens.length && /^[0-9]+$/.test(tokens[tokens.length-1]) && /^[0-9]$/.test(label)){
      tokens[tokens.length-1] += label;
    } else {
      tokens.push(label);
    }

    // show preview tile
    const tile=document.createElement('div'); tile.className='tile';
    const canv=document.createElement('canvas'); canv.width=28; canv.height=28;
    canv.getContext('2d').drawImage(c28,0,0);
    const cap=document.createElement('div'); cap.className='mini'; cap.textContent=label;
    tile.appendChild(canv); tile.appendChild(cap); charsEl.appendChild(tile);
  }

  const exprStr = tokens.join('');
  exprEl.textContent = exprStr || '—';

  try{
    const value = evaluateTokens(tokens);
    ansEl.textContent = String(value);
  }catch(e){
    ansEl.textContent = 'Error';
    console.error(e);
  }
};

/* === Safe evaluator: + - / ( ) and unary √ === */
function evaluateTokens(toks){
  if(!toks.length) throw new Error('empty');
  const valid = new Set(['+','-','/','√','(',')']);
  const out = [];
  toks.forEach(t=>{
    if(/^[0-9]+$/.test(t)) out.push({type:'num', value:parseFloat(t)});
    else if(valid.has(t)) out.push({type:'op', value:t});
    else throw new Error('bad token '+t);
  });
  const prec={'+':1,'-':1,'/':2,'√':3}, right=new Set(['√']);
  const output=[], ops=[];
  for(const tk of out){
    if(tk.type==='num') output.push(tk);
    else if(tk.value==='(') ops.push('(');
    else if(tk.value===')'){
      while(ops.length && ops[ops.length-1]!=='(') output.push({type:'op',value:ops.pop()});
      if(!ops.length) throw new Error('paren mismatch'); ops.pop();
    }else{
      const o1=tk.value;
      while(ops.length){
        const o2=ops[ops.length-1]; if(o2==='(') break;
        if((!right.has(o1) && prec[o1] <= prec[o2]) || (right.has(o1) && prec[o1] < prec[o2])){
          output.push({type:'op', value:ops.pop()});
        }else break;
      }
      ops.push(o1);
    }
  }
  while(ops.length){ const o=ops.pop(); if(o==='(') throw new Error('paren'); output.push({type:'op',value:o}); }
  const st=[];
  for(const t of output){
    if(t.type==='num') st.push(t.value);
    else if(t.value==='√'){ if(st.length<1) throw new Error('sqrt'); const x=st.pop(); if(x<0) throw new Error('sqrtneg'); st.push(Math.sqrt(x)); }
    else{ if(st.length<2) throw new Error('bin'); const b=st.pop(), a=st.pop(); if(t.value==='+') st.push(a+b); else if(t.value==='-') st.push(a-b); else if(t.value==='/'){ if(b===0) throw new Error('div0'); st.push(a/b);} }
  }
  if(st.length!==1) throw new Error('eval');
  return Math.round(st[0]*1e10)/1e10;
}
</script>
</body>
</html>
